{-|
Module      : Botan.Low.HOTP
Description : Hash-based one-time passwords
Copyright   : (c) Leo D, 2023
License     : BSD-3-Clause
Maintainer  : leo@apotheca.io
Stability   : experimental
Portability : POSIX

One time password schemes are a user authentication method that
relies on a fixed secret key which is used to derive a sequence
of short passwords, each of which is accepted only once. Commonly
this is used to implement two-factor authentication (2FA), where
the user authenticates using both a conventional password (or a
public key signature) and an OTP generated by a small device such
as a mobile phone.

Botan implements the HOTP and TOTP schemes from RFC 4226 and 6238.

Since the range of possible OTPs is quite small, applications must
rate limit OTP authentication attempts to some small number per 
second. Otherwise an attacker could quickly try all 1000000 6-digit
OTPs in a brief amount of time.

HOTP generates OTPs that are a short numeric sequence, between 6
and 8 digits (most applications use 6 digits), created using the
HMAC of a 64-bit counter value. If the counter ever repeats the
OTP will also repeat, thus both parties must assure the counter
only increments and is never repeated or decremented. Thus both
client and server must keep track of the next counter expected.

Anyone with access to the client-specific secret key can authenticate
as that client, so it should be treated with the same security
consideration as would be given to any other symmetric key or
plaintext password.
-}

module Botan.Low.HOTP where

import qualified Data.ByteString as ByteString

import Botan.Bindings.HOTP
import Botan.Low.Hash

import Botan.Low.Error
import Botan.Low.Make
import Botan.Low.Prelude
import Botan.Low.Remake

-- NOTE: RFC 4226
-- NOTE: I think this *only* takes SHA-2, specificaly "SHA-256" and "SHA-512",
--  and probably because the RFC specifically uses it?

-- /**
-- * HOTP
-- */

newtype HOTP = MkHOTP { getHOTPForeignPtr :: ForeignPtr BotanHOTPStruct }

newHOTP      :: BotanHOTP -> IO HOTP
withHOTP     :: HOTP -> (BotanHOTP -> IO a) -> IO a
hotpDestroy  :: HOTP -> IO ()
createHOTP   :: (Ptr BotanHOTP -> IO CInt) -> IO HOTP
(newHOTP, withHOTP, hotpDestroy, createHOTP, _)
    = mkBindings
        MkBotanHOTP runBotanHOTP
        MkHOTP getHOTPForeignPtr
        botan_hotp_destroy

type HOTPHashName = HashName

pattern HOTP_SHA_1 
    ,   HOTP_SHA_256
    ,   HOTP_SHA_512
    ::  HOTPHashName

pattern HOTP_SHA_1   = SHA_1
pattern HOTP_SHA_256 = SHA_256
pattern HOTP_SHA_512 = SHA_512

-- TODO: Do any other hashes work?
hotpHashes =
    [ HOTP_SHA_1
    , HOTP_SHA_256
    , HOTP_SHA_512
    ]

type HOTPCounter = Word64
type HOTPCode = Word32

-- NOTE: Digits should be 6-8
hotpInit :: ByteString -> HashName -> Int -> IO HOTP
hotpInit key algo digits = asBytesLen key $ \ keyPtr keyLen -> do
    asCString algo $ \ algoPtr -> do
        createHOTP $ \ out -> botan_hotp_init 
            out
            (ConstPtr keyPtr)
            keyLen
            (ConstPtr algoPtr)
            (fromIntegral digits)

-- WARNING: withFooInit-style limited lifetime functions moved to high-level botan
withHOTPInit :: ByteString -> ByteString -> Int -> (HOTP -> IO a) -> IO a
withHOTPInit = mkWithTemp3 hotpInit hotpDestroy

-- NOTE: User is responsible for incrementing counter at this level
hotpGenerate :: HOTP -> HOTPCounter -> IO HOTPCode
hotpGenerate hotp counter = withHOTP hotp $ \ hotpPtr -> do
    alloca $ \ outPtr -> do
        throwBotanIfNegative $ botan_hotp_generate hotpPtr outPtr counter
        peek outPtr

-- NOTE:
--      "Returns a pair of (is_valid,next_counter_to_use). If the OTP is
--      invalid then always returns (false,starting_counter), since the
--      last successful authentication counter has not changed. ""
-- NOTE: "Depending on the environment a resync_range of 3 to 10 might be appropriate."
hotpCheck :: HOTP -> HOTPCode -> HOTPCounter -> Int -> IO (Bool, HOTPCounter)
hotpCheck hotp code counter resync = withHOTP hotp $ \ hotpPtr -> do
    alloca $ \ outPtr -> do
        valid <- throwBotanCatchingSuccess $ botan_hotp_check hotpPtr outPtr code counter (fromIntegral resync)
        nextCounter <- peek outPtr
        return (valid, nextCounter)
